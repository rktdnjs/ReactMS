복습

3-1
Component : 앱을 이루는 최소한의 단위
- props 혹은 state값을 받아 DOM 노드 생성
- 이름은 항상 대문자로 시작해야함.(소문자로 시작해버리면 HTML태그로 취급함)

컴포넌트의 선언 방식 크게 2가지!
1.class(옛날 방식)
2.function(최근 방식, HOT 함)
리액트 메뉴얼에서도 함수형 + hooks 사용을 권장함
그냥 대충 함수형 컴포넌트가 짱짱맨이라고 생각하면 됨(주로 사용)

function App() {
    return
        뭐시기
}
이런 형태임


Props란?
properties : 컴포넌트 속성 설정 시에 사용하는 요소
특정 값을 컴포넌트에 전달해주기 위해 사용한다.
부모 컴포넌트에서 props의 값을 설정하여, 자식 컴포넌트로 전달해준다.
defaultProps라 해서 별도의 props값이 없는 경우 보여주는 기본 값을 설정할 수도 있다.
MyComponent.defaultProps = {
    grade: "기본값",
};
이런식으로 별도로 props값이 전달되지 않았을 경우 기본값을 설정 가능하다!

근데 계속해서 props를 전달받을때 props.grade이런식으로 안받아도 되고
그냥 바로 비구조화 할당 문법을 통해 props.grade가 아닌, {grade}로 바로 받아올 수 있다.
function MyComponent({grade}) {
    return (
        <div>
            {grade} 하이용 ㅎㅎ
        </div>
    )
}
이때는 저기 props를 전달받는 자리에, props 키워드가 아닌 그냥 바로 
접근하려는 props의 속성값을 {} 중괄호 안에 적어서 사용해주면 된다.


State란?
state : 컴포넌트 내부에서 바뀔 수 있는 값
함수형 컴포넌트 : useState라는 함수를 통해 사용한다.(최신형)
클래스형 컴포넌트 : 지니고 있는 state
바로바로 변하는 하트 이미지 변화등을 주기위해서 useState를 사용 가능하다.

const [button, setButton] = useState(true);
이런식으로 사용하면, 이때 배열의 1번째는 우리가 변화시키려는 변수
2번재에는 그 변수를 변화시키기 위해 사용하는 함수가 들어간다.
이때 이름은 관습적으로 set + 변수이름 이런식으로 하는데, 마음대로 해도 상관없다.
그리고 useState의 소괄호안에는 변수의 초기값이 들어간다고 생각하면 된다.


챠!!!!
props와 state가 되게 비슷해보인다.
뭔가를 전달하고, 사용하는게 헷갈릴 수 있어 이 부분을 한 번 정리해보자.

[props]
- 부모 컴포넌트 -> 자식 컴포넌트로 데이터 전달
- 읽기 전용으로, 자식 컴포넌트에서 변동 없음

[state]
- 해당 컴포넌트 '내부'에서 데이터 전달
- 변경 가능함(근데 이건 나중에 자세히 알아봐도 될듯, 변경시 re-render을 사용)

렌더링 할 데이터를 담고 있어 둘다 비슷해 보이나, 역할 자체는 다르다.
props는 부모 -> 자식 으로 넘겨주고 state는 컴포넌트 내부에서만 작동한다고 보면 OK


Component의 반복을 효율적으로 쓰기위한 방법
반복되는 형태의 코드는 Map()함수를 써서 효율적으로 관리할 수 있다.
map()함수 : 파라미터로 전달된 함수로 배열 내 각 요소를 원하는 규칙에 따라
변환하여 그 결과로 새로운 배열을 생성해준다.

arr.map(callbackFunction(currentValue, index, array), [thisArg])
callbackFunction : 새로운 배열 요소를 처리하는 함수
currentValue : 현재 처리하고 있는 요소
Index : 현재 처리하고 있는 요소의 index값
array : 현재 처리하고 있는 원본 배열
thisArg : callback 함수 내부에서 사용할 this 레퍼런스
좀 어려운데, 나중에 다시 한번 제대로 알아보도록 하자.

ex)
우리가 어떤 API서버에서 데이터를 끌어와서 axios(리액트에서 지원하는 데이터관리 도구)를
통해서 json형태로 받아왔다고 가정하자.
이때 우리는 해당 데이터를 어떤 변수에 저장해놓고
(아래는 받아온 데이터를 movies에 useState를 통해 넘겨서 사용하는 상태임)
그 변수에다가 map함수를 적용시켜 
{movies.map((movie) => 
          (<Movie
          key={movie.id} 
          id={movie.id}
          year={movie.year}
          coverImg={movie.medium_cover_image}
          title={movie.title} 
          summary={movie.summary} 
          genres={movie.genres}/>
        ))}
movies 배열을 map함수에 집어넣어서, 그것을 movie로 받아와 Movie라는 컴포넌트에
보내주는 작업을 위 코드에서 해주고 있다.

그 다음에 Movie 컴포넌트(자식 컴포넌트)에서 부모 컴포넌트에서 넘긴 데이터를
props.의 형식이 아닌{}의 형태로 전부 받아와서 사용해준다.
function Movie({id, coverImg, title, summary, genres, year}) {
return (
    <div className={styles.movie}>
        <img src={coverImg} alt={title} className={styles.movie__img}/>
        <div>
            <h2 className={styles.movie__title}>
                <Link to={`/movie/${id}`}>{title}</Link>
            </h2>
            <h3 className={styles.movie__year}>{year}</h3>
            <p>{summary.length > 235 ? `${summary.slice(0, 235)}...` : summary}</p>
            <ul className={styles.movie__genres}>
                {genres.map((g) => 
            <li key={g}>{g}</li>)}
            </ul>
        </div>
    </div>
    );
}

또 다른 ex)
const IterationSample = () => {
    const names = ['눈', '얼음', '바람'];
    const nameList = names.map(name => <li>{name}</li>);
    return (
        <ul>{namelist}</ul>
    );
};
names배열을 map함수에 name이라는 이름으로 넣어서 이를 <li>태그를 붙여 반환한다.
이때 해당 작업은 각 원소에 대해서 1번씩 작업되고
이를 이제 최종적으로는 nameList에 담겨 새 배열을 반환하고
그것을 ul태그에 입혀서 보여주는 형식이다.


리액트에서의 key설정
리액트에서는 컴포넌트 배열을 렌더링 했을 경우에 어떤 원소에 변동이 있는지를
알아내기 위해서 key값을 필요로 한다.
map합수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하는 것과 같이 설정함
const nameList = names.map((name, index) =>
<li key={index}>{name}</li>)


useEffect()란?
리액트 컴포넌트가 렌더링 될 때마다 특정 작업을 실행할 수 있게 하는 Hook
형태는 useEffect(function, deps) 이와 같다.
function : 수행하고자 하는 작업
deps : 검사하고자 하는 값 또는 배열, 배열 형태이다.

가장 처음 렌더링 될 때 1번만 실행 하고 싶으면 빈 배열을 deps부분에 넣는다.
-> useEffect(function. [])
특정 props나 state가 바뀔 때 실행하고 싶으면 특정 값을 넣어준다.
-> useEffect(function. [바뀌는 값])
